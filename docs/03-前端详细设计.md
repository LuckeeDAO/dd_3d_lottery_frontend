# DD 3D å½©ç¥¨å‰ç«¯ è¯¦ç»†è®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **é¡¹ç›®åç§°**: DD 3D Lottery Frontend (3Då½©ç¥¨å‰ç«¯åº”ç”¨)
- **ç‰ˆæœ¬**: v1.0.0
- **æ–‡æ¡£ç±»å‹**: å‰ç«¯è¯¦ç»†è®¾è®¡æ–‡æ¡£
- **åˆ›å»ºæ—¥æœŸ**: 2024-01-XX
- **æœ€åæ›´æ–°**: 2024-01-XX

## ğŸ¯ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†DD 3D Lotteryå‰ç«¯åº”ç”¨çš„å®ç°ç»†èŠ‚ï¼ŒåŒ…æ‹¬ç»„ä»¶è®¾è®¡ã€APIæ¥å£ã€æ•°æ®æ¨¡å‹ã€çŠ¶æ€ç®¡ç†ã€è·¯ç”±é…ç½®ç­‰å…·ä½“å®ç°æ–¹æ¡ˆã€‚

## ğŸ—ï¸ é¡¹ç›®ç»“æ„

### 1.1 ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ components/          # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ ui/            # åŸºç¡€UIç»„ä»¶
â”‚   â”œâ”€â”€ wallet/        # é’±åŒ…ç›¸å…³ç»„ä»¶
â”‚   â”œâ”€â”€ lottery/       # å½©ç¥¨ç›¸å…³ç»„ä»¶
â”‚   â””â”€â”€ layout/        # å¸ƒå±€ç»„ä»¶
â”œâ”€â”€ pages/             # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ Home/          # é¦–é¡µ
â”‚   â”œâ”€â”€ Bet/           # æŠ•æ³¨é¡µé¢
â”‚   â”œâ”€â”€ Reveal/        # æ­ç§˜é¡µé¢
â”‚   â”œâ”€â”€ Result/        # ç»“æœé¡µé¢
â”‚   â””â”€â”€ History/       # å†å²é¡µé¢
â”œâ”€â”€ services/          # æœåŠ¡å±‚
â”‚   â”œâ”€â”€ wallet/        # é’±åŒ…æœåŠ¡
â”‚   â”œâ”€â”€ contract/      # åˆçº¦æœåŠ¡
â”‚   â”œâ”€â”€ api/          # APIæœåŠ¡
â”‚   â””â”€â”€ storage/      # å­˜å‚¨æœåŠ¡
â”œâ”€â”€ hooks/            # è‡ªå®šä¹‰Hooks
â”‚   â”œâ”€â”€ useWallet.ts
â”‚   â”œâ”€â”€ useContract.ts
â”‚   â”œâ”€â”€ useLottery.ts
â”‚   â””â”€â”€ useTheme.ts
â”œâ”€â”€ stores/           # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ walletStore.ts
â”‚   â”œâ”€â”€ lotteryStore.ts
â”‚   â””â”€â”€ uiStore.ts
â”œâ”€â”€ types/            # ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ wallet.ts
â”‚   â”œâ”€â”€ contract.ts
â”‚   â”œâ”€â”€ lottery.ts
â”‚   â””â”€â”€ common.ts
â”œâ”€â”€ utils/            # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ constants.ts
â”‚   â”œâ”€â”€ helpers.ts
â”‚   â”œâ”€â”€ validators.ts
â”‚   â””â”€â”€ formatters.ts
â”œâ”€â”€ styles/           # æ ·å¼æ–‡ä»¶
â”‚   â”œâ”€â”€ globals.css
â”‚   â”œâ”€â”€ components.css
â”‚   â””â”€â”€ pages.css
â”œâ”€â”€ locales/          # å›½é™…åŒ–
â”‚   â”œâ”€â”€ zh.json
â”‚   â””â”€â”€ en.json
â””â”€â”€ App.tsx           # åº”ç”¨å…¥å£
```

### 1.2 æ–‡ä»¶å‘½åè§„èŒƒ

```yaml
naming_conventions:
  components:
    pattern: "PascalCase"
    example: "WalletConnect.tsx"
    
  pages:
    pattern: "PascalCase"
    example: "BetPage.tsx"
    
  hooks:
    pattern: "camelCase"
    example: "useWallet.ts"
    
  services:
    pattern: "camelCase"
    example: "walletService.ts"
    
  types:
    pattern: "camelCase"
    example: "walletTypes.ts"
    
  utils:
    pattern: "camelCase"
    example: "walletUtils.ts"
```

## ğŸ§© ç»„ä»¶è®¾è®¡

### 2.1 åŸºç¡€UIç»„ä»¶

#### 2.1.1 Buttonç»„ä»¶

```typescript
// components/ui/Button.tsx
import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/utils/helpers';

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
  loading?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, loading, children, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        disabled={loading || props.disabled}
        {...props}
      >
        {loading && (
          <svg className="mr-2 h-4 w-4 animate-spin" viewBox="0 0 24 24">
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            />
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            />
          </svg>
        )}
        {children}
      </button>
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };
```

#### 2.1.2 Inputç»„ä»¶

```typescript
// components/ui/Input.tsx
import React from 'react';
import { cn } from '@/utils/helpers';

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
  helper?: string;
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, label, error, helper, ...props }, ref) => {
    return (
      <div className="space-y-2">
        {label && (
          <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
            {label}
          </label>
        )}
        <input
          type={type}
          className={cn(
            "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
            error && "border-destructive focus-visible:ring-destructive",
            className
          )}
          ref={ref}
          {...props}
        />
        {error && (
          <p className="text-sm text-destructive">{error}</p>
        )}
        {helper && !error && (
          <p className="text-sm text-muted-foreground">{helper}</p>
        )}
      </div>
    );
  }
);

Input.displayName = "Input";

export { Input };
```

#### 2.1.3 Cardç»„ä»¶

```typescript
// components/ui/Card.tsx
import React from 'react';
import { cn } from '@/utils/helpers';

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
```

### 2.2 é’±åŒ…ç»„ä»¶

#### 2.2.1 WalletConnectç»„ä»¶

```typescript
// components/wallet/WalletConnect.tsx
import React, { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/Card';
import { useWallet } from '@/hooks/useWallet';
import { WalletType } from '@/types/wallet';

const WalletConnect: React.FC = () => {
  const { connect, disconnect, connected, address, balance, loading } = useWallet();
  const [selectedWallet, setSelectedWallet] = useState<WalletType | null>(null);

  const handleConnect = async (walletType: WalletType) => {
    setSelectedWallet(walletType);
    try {
      await connect(walletType);
    } catch (error) {
      console.error('Failed to connect wallet:', error);
    } finally {
      setSelectedWallet(null);
    }
  };

  const handleDisconnect = async () => {
    try {
      await disconnect();
    } catch (error) {
      console.error('Failed to disconnect wallet:', error);
    }
  };

  if (connected) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>é’±åŒ…å·²è¿æ¥</CardTitle>
          <CardDescription>æ‚¨çš„é’±åŒ…å·²æˆåŠŸè¿æ¥</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <p className="text-sm font-medium">åœ°å€:</p>
            <p className="text-sm text-muted-foreground font-mono">{address}</p>
          </div>
          <div>
            <p className="text-sm font-medium">ä½™é¢:</p>
            <p className="text-sm text-muted-foreground">{balance} USDC</p>
          </div>
          <Button onClick={handleDisconnect} variant="outline" className="w-full">
            æ–­å¼€è¿æ¥
          </Button>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>è¿æ¥é’±åŒ…</CardTitle>
        <CardDescription>è¯·é€‰æ‹©æ‚¨çš„é’±åŒ…è¿›è¡Œè¿æ¥</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <Button
          onClick={() => handleConnect(WalletType.KEPLR)}
          disabled={loading}
          className="w-full"
        >
          {selectedWallet === WalletType.KEPLR && loading ? 'è¿æ¥ä¸­...' : 'è¿æ¥ Keplr'}
        </Button>
        <Button
          onClick={() => handleConnect(WalletType.COSMOSTATION)}
          disabled={loading}
          variant="outline"
          className="w-full"
        >
          {selectedWallet === WalletType.COSMOSTATION && loading ? 'è¿æ¥ä¸­...' : 'è¿æ¥ Cosmostation'}
        </Button>
      </CardContent>
    </Card>
  );
};

export default WalletConnect;
```

#### 2.2.2 WalletStatusç»„ä»¶

```typescript
// components/wallet/WalletStatus.tsx
import React from 'react';
import { useWallet } from '@/hooks/useWallet';
import { Badge } from '@/components/ui/Badge';
import { Button } from '@/components/ui/Button';

const WalletStatus: React.FC = () => {
  const { connected, address, balance, network } = useWallet();

  if (!connected) {
    return (
      <div className="flex items-center space-x-2">
        <Badge variant="destructive">æœªè¿æ¥</Badge>
      </div>
    );
  }

  return (
    <div className="flex items-center space-x-4">
      <div className="flex items-center space-x-2">
        <Badge variant="success">å·²è¿æ¥</Badge>
        <span className="text-sm text-muted-foreground">{network}</span>
      </div>
      <div className="text-sm">
        <p className="font-medium">{address?.slice(0, 6)}...{address?.slice(-4)}</p>
        <p className="text-muted-foreground">{balance} USDC</p>
      </div>
    </div>
  );
};

export default WalletStatus;
```

### 2.3 å½©ç¥¨ç»„ä»¶

#### 2.3.1 LotteryPhaseç»„ä»¶

```typescript
// components/lottery/LotteryPhase.tsx
import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/Card';
import { Badge } from '@/components/ui/Badge';
import { useLottery } from '@/hooks/useLottery';
import { LotteryPhase as Phase } from '@/types/lottery';

const LotteryPhase: React.FC = () => {
  const { currentSession, phase, timeRemaining } = useLottery();

  const getPhaseInfo = (phase: Phase) => {
    switch (phase) {
      case Phase.COMMITMENT:
        return {
          title: 'æ‰¿è¯ºé˜¶æ®µ',
          description: 'æäº¤æ‚¨çš„æŠ•æ³¨æ‰¿è¯º',
          color: 'bg-blue-500',
          badge: 'æŠ•æ³¨ä¸­'
        };
      case Phase.REVEAL:
        return {
          title: 'æ­ç§˜é˜¶æ®µ',
          description: 'æ­ç¤ºæ‚¨çš„éšæœºæ•°å’Œå¹¸è¿æ•°å­—',
          color: 'bg-yellow-500',
          badge: 'æ­ç§˜ä¸­'
        };
      case Phase.SETTLEMENT:
        return {
          title: 'ç»“ç®—é˜¶æ®µ',
          description: 'è®¡ç®—ä¸­å¥–å·ç å¹¶åˆ†é…å¥–é‡‘',
          color: 'bg-green-500',
          badge: 'ç»“ç®—ä¸­'
        };
      default:
        return {
          title: 'æœªçŸ¥é˜¶æ®µ',
          description: 'ç³»ç»ŸçŠ¶æ€å¼‚å¸¸',
          color: 'bg-gray-500',
          badge: 'æœªçŸ¥'
        };
    }
  };

  const phaseInfo = getPhaseInfo(phase);

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center space-x-2">
          <span>å½“å‰é˜¶æ®µ</span>
          <Badge variant="outline">{phaseInfo.badge}</Badge>
        </CardTitle>
        <CardDescription>{phaseInfo.description}</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex items-center space-x-2">
            <div className={`w-3 h-3 rounded-full ${phaseInfo.color}`} />
            <span className="font-medium">{phaseInfo.title}</span>
          </div>
          {timeRemaining > 0 && (
            <div className="text-sm text-muted-foreground">
              å‰©ä½™æ—¶é—´: {Math.floor(timeRemaining / 60)}åˆ†{timeRemaining % 60}ç§’
            </div>
          )}
          {currentSession && (
            <div className="text-sm">
              <p>ä¼šè¯ID: {currentSession.sessionId}</p>
              <p>æ€»å¥–é‡‘æ± : {currentSession.totalPool} USDC</p>
              <p>å‚ä¸è€…: {currentSession.participants.length}äºº</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

export default LotteryPhase;
```

#### 2.3.2 BetFormç»„ä»¶

```typescript
// components/lottery/BetForm.tsx
import React, { useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import { Input } from '@/components/ui/Input';
import { useLottery } from '@/hooks/useLottery';
import { useWallet } from '@/hooks/useWallet';

const BetForm: React.FC = () => {
  const { placeBet, loading } = useLottery();
  const { connected, balance } = useWallet();
  const [betAmount, setBetAmount] = useState('');
  const [luckyNumbers, setLuckyNumbers] = useState<number[]>([]);
  const [randomSeed, setRandomSeed] = useState('');

  const handleBetAmountChange = (value: string) => {
    const amount = parseInt(value);
    if (amount > 0 && amount <= balance) {
      setBetAmount(value);
      // ç”Ÿæˆå¯¹åº”æ•°é‡çš„å¹¸è¿æ•°å­—
      const numbers = Array.from({ length: amount }, () => 
        Math.floor(Math.random() * 1000)
      );
      setLuckyNumbers(numbers);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!connected) return;

    try {
      await placeBet({
        betAmount: parseInt(betAmount),
        luckyNumbers,
        randomSeed
      });
    } catch (error) {
      console.error('Failed to place bet:', error);
    }
  };

  if (!connected) {
    return (
      <Card>
        <CardContent className="p-6">
          <p className="text-center text-muted-foreground">
            è¯·å…ˆè¿æ¥é’±åŒ…
          </p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>æŠ•æ³¨</CardTitle>
        <CardDescription>é€‰æ‹©æŠ•æ³¨é‡‘é¢å’Œå¹¸è¿æ•°å­—</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            label="æŠ•æ³¨é‡‘é¢"
            type="number"
            value={betAmount}
            onChange={(e) => handleBetAmountChange(e.target.value)}
            placeholder="è¾“å…¥æŠ•æ³¨é‡‘é¢"
            min="1"
            max={balance.toString()}
            helper={`å¯ç”¨ä½™é¢: ${balance} USDC`}
          />
          
          {luckyNumbers.length > 0 && (
            <div>
              <label className="text-sm font-medium">å¹¸è¿æ•°å­—</label>
              <div className="mt-2 grid grid-cols-5 gap-2">
                {luckyNumbers.map((number, index) => (
                  <div
                    key={index}
                    className="p-2 text-center border rounded-md bg-muted"
                  >
                    {number}
                  </div>
                ))}
              </div>
            </div>
          )}

          <Input
            label="éšæœºç§å­"
            value={randomSeed}
            onChange={(e) => setRandomSeed(e.target.value)}
            placeholder="è¾“å…¥éšæœºç§å­"
            helper="ç”¨äºç”Ÿæˆæ‰¿è¯ºå“ˆå¸Œçš„éšæœºå­—ç¬¦ä¸²"
          />

          <Button
            type="submit"
            disabled={loading || !betAmount || !randomSeed}
            className="w-full"
          >
            {loading ? 'æŠ•æ³¨ä¸­...' : 'ç¡®è®¤æŠ•æ³¨'}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
};

export default BetForm;
```

## ğŸ”Œ æœåŠ¡å±‚è®¾è®¡

### 3.1 é’±åŒ…æœåŠ¡

```typescript
// services/wallet/walletService.ts
import { WalletType } from '@/types/wallet';
import { AccountInfo, Balance } from '@/types/common';

export interface WalletService {
  connect(walletType: WalletType): Promise<void>;
  disconnect(): Promise<void>;
  getAccount(): Promise<AccountInfo>;
  getBalance(denom: string): Promise<Balance>;
  sendTransaction(tx: any): Promise<string>;
  signMessage(message: string): Promise<string>;
  on(event: string, callback: Function): void;
  off(event: string, callback: Function): void;
}

class WalletServiceImpl implements WalletService {
  private wallet: any = null;
  private listeners: Map<string, Function[]> = new Map();

  async connect(walletType: WalletType): Promise<void> {
    try {
      switch (walletType) {
        case WalletType.KEPLR:
          await this.connectKeplr();
          break;
        case WalletType.COSMOSTATION:
          await this.connectCosmostation();
          break;
        default:
          throw new Error('Unsupported wallet type');
      }
    } catch (error) {
      console.error('Failed to connect wallet:', error);
      throw error;
    }
  }

  private async connectKeplr(): Promise<void> {
    if (!window.keplr) {
      throw new Error('Keplr wallet not found');
    }

    try {
      await window.keplr.enable(process.env.REACT_APP_CHAIN_ID);
      this.wallet = window.keplr;
      this.emit('connected', { type: WalletType.KEPLR });
    } catch (error) {
      throw new Error('Failed to enable Keplr wallet');
    }
  }

  private async connectCosmostation(): Promise<void> {
    if (!window.cosmostation) {
      throw new Error('Cosmostation wallet not found');
    }

    try {
      await window.cosmostation.cosmos.request({
        method: 'cosmos_requestAccount',
        params: { chainName: process.env.REACT_APP_CHAIN_ID }
      });
      this.wallet = window.cosmostation;
      this.emit('connected', { type: WalletType.COSMOSTATION });
    } catch (error) {
      throw new Error('Failed to connect Cosmostation wallet');
    }
  }

  async disconnect(): Promise<void> {
    this.wallet = null;
    this.emit('disconnected', {});
  }

  async getAccount(): Promise<AccountInfo> {
    if (!this.wallet) {
      throw new Error('Wallet not connected');
    }

    try {
      const account = await this.wallet.getKey(process.env.REACT_APP_CHAIN_ID);
      return {
        address: account.bech32Address,
        pubKey: account.pubKey,
        algo: account.algo,
        isNanoLedger: account.isNanoLedger
      };
    } catch (error) {
      throw new Error('Failed to get account info');
    }
  }

  async getBalance(denom: string): Promise<Balance> {
    if (!this.wallet) {
      throw new Error('Wallet not connected');
    }

    try {
      const account = await this.getAccount();
      const response = await fetch(
        `${process.env.REACT_APP_RPC_URL}/cosmos/bank/v1beta1/balances/${account.address}`
      );
      const data = await response.json();
      
      const balance = data.balances.find((b: any) => b.denom === denom);
      return {
        denom,
        amount: balance ? balance.amount : '0'
      };
    } catch (error) {
      throw new Error('Failed to get balance');
    }
  }

  async sendTransaction(tx: any): Promise<string> {
    if (!this.wallet) {
      throw new Error('Wallet not connected');
    }

    try {
      const result = await this.wallet.signAndBroadcast(
        process.env.REACT_APP_CHAIN_ID,
        tx
      );
      return result.transactionHash;
    } catch (error) {
      throw new Error('Failed to send transaction');
    }
  }

  async signMessage(message: string): Promise<string> {
    if (!this.wallet) {
      throw new Error('Wallet not connected');
    }

    try {
      const result = await this.wallet.signMessage(
        process.env.REACT_APP_CHAIN_ID,
        message
      );
      return result.signature;
    } catch (error) {
      throw new Error('Failed to sign message');
    }
  }

  on(event: string, callback: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(callback);
  }

  off(event: string, callback: Function): void {
    if (!this.listeners.has(event)) return;
    const callbacks = this.listeners.get(event)!;
    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
    }
  }

  private emit(event: string, data: any): void {
    if (!this.listeners.has(event)) return;
    this.listeners.get(event)!.forEach(callback => callback(data));
  }
}

export const walletService = new WalletServiceImpl();
```

### 3.2 åˆçº¦æœåŠ¡

```typescript
// services/contract/contractService.ts
import { CosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { ContractAddress } from '@/types/contract';
import { LotterySession, ParticipantInfo, LotteryResult } from '@/types/lottery';

export interface ContractService {
  getCurrentSession(): Promise<LotterySession>;
  getParticipantInfo(address: string): Promise<ParticipantInfo>;
  getLotteryResult(sessionId: string): Promise<LotteryResult>;
  placeBet(commitmentHash: string): Promise<string>;
  revealRandom(luckyNumbers: number[], randomSeed: string): Promise<string>;
  settleLottery(): Promise<string>;
}

class ContractServiceImpl implements ContractService {
  private client: CosmWasmClient | null = null;
  private contractAddress: string;

  constructor() {
    this.contractAddress = process.env.REACT_APP_CONTRACT_ADDRESS || '';
  }

  private async getClient(): Promise<CosmWasmClient> {
    if (!this.client) {
      this.client = await CosmWasmClient.connect(process.env.REACT_APP_RPC_URL!);
    }
    return this.client;
  }

  async getCurrentSession(): Promise<LotterySession> {
    const client = await this.getClient();
    const query = { get_current_session: {} };
    
    try {
      const response = await client.queryContractSmart(this.contractAddress, query);
      return response.session;
    } catch (error) {
      throw new Error('Failed to get current session');
    }
  }

  async getParticipantInfo(address: string): Promise<ParticipantInfo> {
    const client = await this.getClient();
    const query = { get_participant_info: { participant: address } };
    
    try {
      const response = await client.queryContractSmart(this.contractAddress, query);
      return response.participant;
    } catch (error) {
      throw new Error('Failed to get participant info');
    }
  }

  async getLotteryResult(sessionId: string): Promise<LotteryResult> {
    const client = await this.getClient();
    const query = { get_lottery_result: { session_id: sessionId } };
    
    try {
      const response = await client.queryContractSmart(this.contractAddress, query);
      return response.result;
    } catch (error) {
      throw new Error('Failed to get lottery result');
    }
  }

  async placeBet(commitmentHash: string): Promise<string> {
    const client = await this.getClient();
    const msg = { place_bet: { commitment_hash: commitmentHash } };
    
    try {
      const result = await client.execute(
        process.env.REACT_APP_SENDER_ADDRESS!,
        this.contractAddress,
        msg,
        'auto'
      );
      return result.transactionHash;
    } catch (error) {
      throw new Error('Failed to place bet');
    }
  }

  async revealRandom(luckyNumbers: number[], randomSeed: string): Promise<string> {
    const client = await this.getClient();
    const msg = { 
      reveal_random: { 
        lucky_numbers: luckyNumbers,
        random_seed: randomSeed
      } 
    };
    
    try {
      const result = await client.execute(
        process.env.REACT_APP_SENDER_ADDRESS!,
        this.contractAddress,
        msg,
        'auto'
      );
      return result.transactionHash;
    } catch (error) {
      throw new Error('Failed to reveal random');
    }
  }

  async settleLottery(): Promise<string> {
    const client = await this.getClient();
    const msg = { settle_lottery: {} };
    
    try {
      const result = await client.execute(
        process.env.REACT_APP_SENDER_ADDRESS!,
        this.contractAddress,
        msg,
        'auto'
      );
      return result.transactionHash;
    } catch (error) {
      throw new Error('Failed to settle lottery');
    }
  }
}

export const contractService = new ContractServiceImpl();
```

## ğŸ£ è‡ªå®šä¹‰Hooks

### 4.1 useWallet Hook

```typescript
// hooks/useWallet.ts
import { useState, useEffect, useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { walletService } from '@/services/wallet/walletService';
import { WalletType } from '@/types/wallet';
import { AccountInfo, Balance } from '@/types/common';

export const useWallet = () => {
  const [connected, setConnected] = useState(false);
  const [address, setAddress] = useState<string | null>(null);
  const [balance, setBalance] = useState<Balance | null>(null);
  const [network, setNetwork] = useState<string>('');
  const queryClient = useQueryClient();

  // æŸ¥è¯¢è´¦æˆ·ä¿¡æ¯
  const { data: accountInfo } = useQuery<AccountInfo>({
    queryKey: ['wallet', 'account'],
    queryFn: () => walletService.getAccount(),
    enabled: connected,
    refetchInterval: 30000
  });

  // æŸ¥è¯¢ä½™é¢
  const { data: balanceInfo } = useQuery<Balance>({
    queryKey: ['wallet', 'balance'],
    queryFn: () => walletService.getBalance('uusd'),
    enabled: connected,
    refetchInterval: 10000
  });

  // è¿æ¥é’±åŒ…
  const connectMutation = useMutation({
    mutationFn: (walletType: WalletType) => walletService.connect(walletType),
    onSuccess: () => {
      setConnected(true);
      queryClient.invalidateQueries({ queryKey: ['wallet'] });
    },
    onError: (error) => {
      console.error('Failed to connect wallet:', error);
    }
  });

  // æ–­å¼€è¿æ¥
  const disconnectMutation = useMutation({
    mutationFn: () => walletService.disconnect(),
    onSuccess: () => {
      setConnected(false);
      setAddress(null);
      setBalance(null);
      queryClient.clear();
    }
  });

  // ç›‘å¬é’±åŒ…äº‹ä»¶
  useEffect(() => {
    const handleConnected = (data: any) => {
      setConnected(true);
      setNetwork(data.type);
    };

    const handleDisconnected = () => {
      setConnected(false);
      setAddress(null);
      setBalance(null);
    };

    walletService.on('connected', handleConnected);
    walletService.on('disconnected', handleDisconnected);

    return () => {
      walletService.off('connected', handleConnected);
      walletService.off('disconnected', handleDisconnected);
    };
  }, []);

  // æ›´æ–°åœ°å€å’Œä½™é¢
  useEffect(() => {
    if (accountInfo) {
      setAddress(accountInfo.address);
    }
  }, [accountInfo]);

  useEffect(() => {
    if (balanceInfo) {
      setBalance(balanceInfo);
    }
  }, [balanceInfo]);

  const connect = useCallback((walletType: WalletType) => {
    connectMutation.mutate(walletType);
  }, [connectMutation]);

  const disconnect = useCallback(() => {
    disconnectMutation.mutate();
  }, [disconnectMutation]);

  return {
    connected,
    address,
    balance,
    network,
    loading: connectMutation.isPending || disconnectMutation.isPending,
    connect,
    disconnect
  };
};
```

### 4.2 useLottery Hook

```typescript
// hooks/useLottery.ts
import { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { contractService } from '@/services/contract/contractService';
import { LotterySession, ParticipantInfo, LotteryResult } from '@/types/lottery';
import { LotteryPhase } from '@/types/lottery';

export const useLottery = () => {
  const [phase, setPhase] = useState<LotteryPhase>(LotteryPhase.COMMITMENT);
  const [timeRemaining, setTimeRemaining] = useState(0);
  const queryClient = useQueryClient();

  // æŸ¥è¯¢å½“å‰ä¼šè¯
  const { data: currentSession, isLoading: sessionLoading } = useQuery<LotterySession>({
    queryKey: ['lottery', 'currentSession'],
    queryFn: () => contractService.getCurrentSession(),
    refetchInterval: 5000
  });

  // æŸ¥è¯¢å‚ä¸è€…ä¿¡æ¯
  const { data: participantInfo } = useQuery<ParticipantInfo>({
    queryKey: ['lottery', 'participantInfo'],
    queryFn: () => contractService.getParticipantInfo(''),
    enabled: false
  });

  // æŠ•æ³¨æ“ä½œ
  const placeBetMutation = useMutation({
    mutationFn: (data: { betAmount: number; luckyNumbers: number[]; randomSeed: string }) => {
      // ç”Ÿæˆæ‰¿è¯ºå“ˆå¸Œ
      const commitmentHash = generateCommitmentHash(data.luckyNumbers, data.randomSeed);
      return contractService.placeBet(commitmentHash);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['lottery'] });
    }
  });

  // æ­ç§˜æ“ä½œ
  const revealMutation = useMutation({
    mutationFn: (data: { luckyNumbers: number[]; randomSeed: string }) => {
      return contractService.revealRandom(data.luckyNumbers, data.randomSeed);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['lottery'] });
    }
  });

  // ç»“ç®—æ“ä½œ
  const settleMutation = useMutation({
    mutationFn: () => contractService.settleLottery(),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['lottery'] });
    }
  });

  // è®¡ç®—é˜¶æ®µå’Œå‰©ä½™æ—¶é—´
  useEffect(() => {
    if (currentSession) {
      const now = Date.now();
      const sessionStart = currentSession.createdHeight * 1000; // å‡è®¾æ¯ä¸ªåŒºå—1ç§’
      const elapsed = now - sessionStart;
      const phaseMod = Math.floor(elapsed / 10000) % 3;
      
      switch (phaseMod) {
        case 0:
          setPhase(LotteryPhase.COMMITMENT);
          setTimeRemaining(6000 - (elapsed % 10000));
          break;
        case 1:
          setPhase(LotteryPhase.REVEAL);
          setTimeRemaining(3000 - (elapsed % 10000));
          break;
        case 2:
          setPhase(LotteryPhase.SETTLEMENT);
          setTimeRemaining(1000 - (elapsed % 10000));
          break;
      }
    }
  }, [currentSession]);

  const placeBet = (data: { betAmount: number; luckyNumbers: number[]; randomSeed: string }) => {
    placeBetMutation.mutate(data);
  };

  const revealRandom = (data: { luckyNumbers: number[]; randomSeed: string }) => {
    revealMutation.mutate(data);
  };

  const settleLottery = () => {
    settleMutation.mutate();
  };

  return {
    currentSession,
    phase,
    timeRemaining,
    participantInfo,
    loading: sessionLoading || placeBetMutation.isPending || revealMutation.isPending || settleMutation.isPending,
    placeBet,
    revealRandom,
    settleLottery
  };
};

// ç”Ÿæˆæ‰¿è¯ºå“ˆå¸Œ
function generateCommitmentHash(luckyNumbers: number[], randomSeed: string): string {
  const data = JSON.stringify({ luckyNumbers, randomSeed });
  // è¿™é‡Œåº”è¯¥ä½¿ç”¨å®é™…çš„å“ˆå¸Œå‡½æ•°
  return btoa(data);
}
```

## ğŸ“Š çŠ¶æ€ç®¡ç†

### 5.1 Zustand Store

```typescript
// stores/lotteryStore.ts
import { create } from 'zustand';
import { LotterySession, ParticipantInfo, LotteryResult } from '@/types/lottery';
import { LotteryPhase } from '@/types/lottery';

interface LotteryState {
  // çŠ¶æ€
  currentSession: LotterySession | null;
  phase: LotteryPhase;
  participantInfo: ParticipantInfo | null;
  history: LotteryResult[];
  
  // æ“ä½œ
  setCurrentSession: (session: LotterySession | null) => void;
  setPhase: (phase: LotteryPhase) => void;
  setParticipantInfo: (info: ParticipantInfo | null) => void;
  addToHistory: (result: LotteryResult) => void;
  clearHistory: () => void;
}

export const useLotteryStore = create<LotteryState>((set) => ({
  // åˆå§‹çŠ¶æ€
  currentSession: null,
  phase: LotteryPhase.COMMITMENT,
  participantInfo: null,
  history: [],
  
  // æ“ä½œ
  setCurrentSession: (session) => set({ currentSession: session }),
  setPhase: (phase) => set({ phase }),
  setParticipantInfo: (info) => set({ participantInfo: info }),
  addToHistory: (result) => set((state) => ({ 
    history: [...state.history, result] 
  })),
  clearHistory: () => set({ history: [] })
}));
```

### 5.2 UI Store

```typescript
// stores/uiStore.ts
import { create } from 'zustand';

interface UIState {
  // çŠ¶æ€
  loading: boolean;
  error: string | null;
  theme: 'light' | 'dark';
  language: 'zh' | 'en';
  sidebarOpen: boolean;
  
  // æ“ä½œ
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setTheme: (theme: 'light' | 'dark') => void;
  setLanguage: (language: 'zh' | 'en') => void;
  setSidebarOpen: (open: boolean) => void;
  toggleSidebar: () => void;
}

export const useUIStore = create<UIState>((set) => ({
  // åˆå§‹çŠ¶æ€
  loading: false,
  error: null,
  theme: 'light',
  language: 'zh',
  sidebarOpen: false,
  
  // æ“ä½œ
  setLoading: (loading) => set({ loading }),
  setError: (error) => set({ error }),
  setTheme: (theme) => set({ theme }),
  setLanguage: (language) => set({ language }),
  setSidebarOpen: (open) => set({ sidebarOpen: open }),
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen }))
}));
```

## ğŸ›£ï¸ è·¯ç”±é…ç½®

### 6.1 è·¯ç”±å®šä¹‰

```typescript
// App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ThemeProvider } from '@/components/theme/ThemeProvider';
import { Layout } from '@/components/layout/Layout';
import { HomePage } from '@/pages/Home/HomePage';
import { BetPage } from '@/pages/Bet/BetPage';
import { RevealPage } from '@/pages/Reveal/RevealPage';
import { ResultPage } from '@/pages/Result/ResultPage';
import { HistoryPage } from '@/pages/History/HistoryPage';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 3,
      staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <Router>
          <Layout>
            <Routes>
              <Route path="/" element={<HomePage />} />
              <Route path="/bet" element={<BetPage />} />
              <Route path="/reveal" element={<RevealPage />} />
              <Route path="/result" element={<ResultPage />} />
              <Route path="/history" element={<HistoryPage />} />
            </Routes>
          </Layout>
        </Router>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;
```

### 6.2 é¡µé¢ç»„ä»¶

```typescript
// pages/Home/HomePage.tsx
import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/Card';
import { WalletConnect } from '@/components/wallet/WalletConnect';
import { LotteryPhase } from '@/components/lottery/LotteryPhase';
import { useLottery } from '@/hooks/useLottery';

const HomePage: React.FC = () => {
  const { currentSession, phase } = useLottery();

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-4xl mx-auto space-y-6">
        <div className="text-center space-y-2">
          <h1 className="text-4xl font-bold">DD 3D å½©ç¥¨</h1>
          <p className="text-xl text-muted-foreground">
            å»ä¸­å¿ƒåŒ–3Då½©ç¥¨æ¸¸æˆ
          </p>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <WalletConnect />
          <LotteryPhase />
        </div>

        {currentSession && (
          <Card>
            <CardHeader>
              <CardTitle>å½“å‰ä¼šè¯ä¿¡æ¯</CardTitle>
              <CardDescription>å®æ—¶æ›´æ–°çš„å½©ç¥¨ä¼šè¯çŠ¶æ€</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <p className="text-sm font-medium">ä¼šè¯ID</p>
                  <p className="text-sm text-muted-foreground">{currentSession.sessionId}</p>
                </div>
                <div>
                  <p className="text-sm font-medium">æ€»å¥–é‡‘æ± </p>
                  <p className="text-sm text-muted-foreground">{currentSession.totalPool} USDC</p>
                </div>
                <div>
                  <p className="text-sm font-medium">å‚ä¸è€…</p>
                  <p className="text-sm text-muted-foreground">{currentSession.participants.length}äºº</p>
                </div>
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
};

export default HomePage;
```

## ğŸ“ å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ | å˜æ›´å†…å®¹ | å˜æ›´äºº |
|------|------|----------|--------|
| v1.0 | 2024-01-XX | åˆå§‹è¯¦ç»†è®¾è®¡æ–‡æ¡£åˆ›å»º | AI Assistant |

---

**æ³¨æ„**: æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†DD 3Då½©ç¥¨å‰ç«¯åº”ç”¨çš„å®ç°ç»†èŠ‚ï¼Œæ‰€æœ‰å¼€å‘å·¥ä½œéƒ½å¿…é¡»åŸºäºæ­¤æ–‡æ¡£è¿›è¡Œã€‚
